<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CYDRAIN 的博客</title>
  
  <subtitle>by Darren Cai</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://cydrain.github.io/"/>
  <updated>2017-12-10T10:48:07.000Z</updated>
  <id>http://cydrain.github.io/</id>
  
  <author>
    <name>Darren Cai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Malloc Page</title>
    <link href="http://cydrain.github.io/2017/12/10/Malloc-Page/"/>
    <id>http://cydrain.github.io/2017/12/10/Malloc-Page/</id>
    <published>2017-12-10T10:46:38.000Z</published>
    <updated>2017-12-10T10:48:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>Malloc 一个单独的内存页。</p><p>实现：<br>申请两个内存页的空间，一定包含一个完整的单独内存页。<br>申请到地址为原始地址<code>org_ptr</code>，<br>对原始地址的低地址位清零，得到单独的内存页地址<code>page_ptr</code>，<br>原始地址需要保存在<code>page_ptr - 1</code>的地址上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line"></span><br><span class="line">typedef unsigned long ulong;</span><br><span class="line"></span><br><span class="line">#define PAGE_SIZE 1024</span><br><span class="line">#define PAGE_MASK (~((ulong)0) &lt;&lt; 10)</span><br><span class="line"></span><br><span class="line">void* mallocPage(void)</span><br><span class="line">&#123;</span><br><span class="line">    void *org_ptr = NULL, *page_ptr = NULL;</span><br><span class="line">    ulong *addr_ptr = NULL;</span><br><span class="line"></span><br><span class="line">    org_ptr = malloc(PAGE_SIZE * 2);</span><br><span class="line">    if (org_ptr == NULL) &#123;</span><br><span class="line">        printf(&quot;No enough memory!\n&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    page_ptr = (void*)(((ulong)org_ptr + PAGE_SIZE) &amp; PAGE_MASK);</span><br><span class="line">    addr_ptr = (ulong*)page_ptr - 1;</span><br><span class="line">    *addr_ptr = (ulong)org_ptr;</span><br><span class="line">    printf(&quot;org_ptr = %p, addr_ptr = %p, *addr_ptr = %x, page_ptr = %p\n&quot;,</span><br><span class="line">            org_ptr, addr_ptr, *addr_ptr, page_ptr);</span><br><span class="line">    </span><br><span class="line">    return page_ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void freePage(void* ptr)</span><br><span class="line">&#123;</span><br><span class="line">    void *org_ptr = NULL;</span><br><span class="line"></span><br><span class="line">    if (ptr == NULL) &#123;</span><br><span class="line">        printf(&quot;Invalid ptr!\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    org_ptr = (void*)*((ulong*)ptr - 1);</span><br><span class="line">    printf(&quot;Free %p\n&quot;, org_ptr);</span><br><span class="line"></span><br><span class="line">    free(org_ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    void* ptr[5];</span><br><span class="line">    for (i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">        ptr[i] = mallocPage();</span><br><span class="line">    &#125;</span><br><span class="line">    for (i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">        freePage(ptr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Malloc 一个单独的内存页。&lt;/p&gt;
&lt;p&gt;实现：&lt;br&gt;申请两个内存页的空间，一定包含一个完整的单独内存页。&lt;br&gt;申请到地址为原始地址&lt;code&gt;org_ptr&lt;/code&gt;，&lt;br&gt;对原始地址的低地址位清零，得到单独的内存页地址&lt;code&gt;page_ptr&lt;/co
      
    
    </summary>
    
      <category term="Memory" scheme="http://cydrain.github.io/categories/Memory/"/>
    
    
  </entry>
  
  <entry>
    <title>NEXT theme 使用文档</title>
    <link href="http://cydrain.github.io/2017/12/10/NEXT-theme-%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/"/>
    <id>http://cydrain.github.io/2017/12/10/NEXT-theme-使用文档/</id>
    <published>2017-12-10T09:16:10.000Z</published>
    <updated>2017-12-10T09:35:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="e-x-T"><a href="#e-x-T" class="headerlink" title=" e x T"></a><div align="center"><a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener"><img align="center" width="56" height="56" src="../../blob/master/source/images/logo.svg"></a> e x T</div></h1><p align="center">NexT 是一个高质量并且优雅的<a href="http://hexo.io" target="_blank" rel="noopener">Hexo</a> 主题。这是精心制作做出来的 hexo 主题。</p><p><img src="http://iissnan.com/nexus/next/next-schemes.jpg" alt="NexT Schemes"></p><p><a href="https://gitter.im/iissnan/hexo-theme-next?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge" target="_blank" rel="noopener"><img src="https://badges.gitter.im/Join%20Chat.svg" alt="Join the chat at https://gitter.im/iissnan/hexo-theme-next"></a><br><a href="https://github.com/iissnan/hexo-theme-next/commits/master" target="_blank" rel="noopener"><img src="https://img.shields.io/maintenance/yes/2017.svg" alt="mnt-image"></a><br><a href="https://travis-ci.org/iissnan/hexo-theme-next?branch=master" title="Travis CI" target="_blank" rel="noopener"><img src="https://travis-ci.org/iissnan/hexo-theme-next.svg?branch=master" alt="travis-image"></a><br><a href="https://github.com/iissnan/hexo-theme-next/releases" target="_blank" rel="noopener"><img src="https://img.shields.io/github/release/iissnan/hexo-theme-next.svg" alt="rel-image"></a><br><a href="http://hexo.io" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/hexo-%3E%3D%203.0-blue.svg" alt="hexo-image"></a><br><a href="LICENSE"><img src="https://img.shields.io/dub/l/vibe-d.svg" alt="lic-image"></a></p><ul><li><a href="http://theme-next.iissnan.com" target="_blank">NexT 使用文档</a> |  <a href="README.md">English Documentation</a></li></ul><h2 id="实时预览-Live-Preview"><a href="#实时预览-Live-Preview" class="headerlink" title="实时预览 Live Preview"></a>实时预览 Live Preview</h2><ul><li>:heart_decoration: Muse 方案: <a href="https://notes.wanghao.work" target="_blank" rel="noopener">XiaMo</a> | <a href="https://oawan.me" target="_blank" rel="noopener">OAwan</a> | <a href="http://hui-wang.info" target="_blank" rel="noopener">Hui Wang</a></li><li>:six_pointed_star: Mist 方案: <a href="https://blog.zzbd.org" target="_blank" rel="noopener">Jeff</a> | <a href="http://uchuhimo.me" target="_blank" rel="noopener">uchuhimo</a> | <a href="http://www.ixirong.com" target="_blank" rel="noopener">xirong</a></li><li>:pisces: Pisces 方案: <a href="http://notes.iissnan.com" target="_blank" rel="noopener">Vi</a> | <a href="https://acris.me" target="_blank" rel="noopener">Acris</a> | <a href="https://rainylog.com" target="_blank" rel="noopener">Rainy</a></li><li>:gemini: Gemini 方案: <a href="https://almostover.ru" target="_blank" rel="noopener">Ivan.Nginx</a> | <a href="http://sh.alynx.xyz" target="_blank" rel="noopener">Alynx</a> | <a href="https://raincal.top" target="_blank" rel="noopener">Raincal</a></li></ul><p>更多 NexT 例子点击 <a href="https://github.com/iissnan/hexo-theme-next/issues/119" target="_blank" rel="noopener">这里</a>.</p><h2 id="安装-Installation"><a href="#安装-Installation" class="headerlink" title="安装 Installation"></a>安装 Installation</h2><p><strong>1.</strong> 在终端切换到<strong>hexo 根</strong>目录. 在hexo目录下一定有 <code>node_modules</code>, <code>source</code>, <code>themes</code> 和其他文件夹:<br>   <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> hexo</span><br><span class="line">$ ls</span><br><span class="line">_config.yml  node_modules  package.json  public  scaffolds  <span class="built_in">source</span>  themes</span><br></pre></td></tr></table></figure></p><p><strong>2.</strong> 从 github 上获取主题 。这里有几种方式来获取主题:</p><h3 id="下载最新发布的版本-Download-tagged-release-version"><a href="#下载最新发布的版本-Download-tagged-release-version" class="headerlink" title="下载最新发布的版本  Download tagged release version"></a>下载<a href="https://github.com/iissnan/hexo-theme-next/releases/latest" target="_blank" rel="noopener">最新发布的版本</a>  Download tagged release version</h3><p>   在大多数情况下 <strong>稳定</strong>。 推荐用户下载这个。</p><p>   <a href="http://lmgtfy.com/?q=linux+curl+tar+wget+install" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/install%20with%20-curl%20%7C%20tar%20%7C%20wget-blue.svg" alt="curl-tar-wget-image"></a></p>   <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir themes/next</span><br><span class="line">$ curl -s https://api.github.com/repos/iissnan/hexo-theme-next/releases/latest | grep tarball_url | cut -d <span class="string">'"'</span> -f 4 | wget -i - -O- | tar -zx -C themes/next --strip-components=1</span><br></pre></td></tr></table></figure><h3 id="下载标签发布版本-Download-tagged-release-version"><a href="#下载标签发布版本-Download-tagged-release-version" class="headerlink" title="下载标签发布版本  Download tagged release version"></a>下载<a href="https://github.com/iissnan/hexo-theme-next/releases" target="_blank" rel="noopener">标签发布版本</a>  Download tagged release version</h3><p>   您必须定义版本。从<a href="https://github.com/iissnan/hexo-theme-next/tags" target="_blank" rel="noopener">标签列表</a>里选择版本替换<code>v5.1.2</code>。</p><p>   <a href="http://lmgtfy.com/?q=linux+curl+tar+install" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/install%20with%20-curl%20%7C%20tar-blue.svg" alt="curl-tar-image"></a></p>   <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir themes/next</span><br><span class="line">$ curl -L https://api.github.com/repos/iissnan/hexo-theme-next/tarball/v5.1.2 | tar -zxv -C themes/next --strip-components=1</span><br></pre></td></tr></table></figure><p>   <a href="http://lmgtfy.com/?q=linux+git+install" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/install%20with%20-git-blue.svg" alt="git-image"></a></p>   <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> --branch v5.1.2 https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><h3 id="下载最新的-master-分支-Download-latest-master-branch"><a href="#下载最新的-master-分支-Download-latest-master-branch" class="headerlink" title="下载最新的 master 分支  Download latest master branch"></a>下载<a href="https://github.com/iissnan/hexo-theme-next/archive/master.zip" target="_blank" rel="noopener">最新的 master 分支</a>  Download latest master branch</h3><p>  可能会 <strong>不稳定</strong>, 但是包含最新的特色，推荐开发者下载.</p><p>   <a href="http://lmgtfy.com/?q=linux+curl+tar+install" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/install%20with%20-curl%20%7C%20tar-blue.svg" alt="curl-tar-image"></a></p>   <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir themes/next</span><br><span class="line">$ curl -L https://api.github.com/repos/iissnan/hexo-theme-next/tarball | tar -zxv -C themes/next --strip-components=1</span><br></pre></td></tr></table></figure><p>   <a href="http://lmgtfy.com/?q=linux+git+install" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/install%20with%20-git-blue.svg" alt="git-image"></a></p>   <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>  使用克隆命令，你将得到<strong>整个存储库</strong>。而且在任何时候你都可以切换到任何标签发布版本。<br>  获取标签列表：</p>   <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> themes/next</span><br><span class="line">$ git tag -l</span><br><span class="line">…</span><br><span class="line">v5.0.0</span><br><span class="line">v5.0.1</span><br><span class="line">v5.1.0</span><br><span class="line">v5.1.1</span><br><span class="line">v5.1.2</span><br></pre></td></tr></table></figure><p>   例如, 你想要切换到<code>v5.1.0</code> <a href="https://github.com/iissnan/hexo-theme-next/tags" target="_blank" rel="noopener">标签发布版本</a>. 输入以下命令:</p>   <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout tags/v5.1.0</span><br><span class="line">Note: checking out <span class="string">'tags/v5.1.0'</span>.</span><br><span class="line">…</span><br><span class="line">HEAD now on 1f72f68... CSS: Remove global list-style setting of ul</span><br></pre></td></tr></table></figure><p>   如果你想切换回 <a href="https://github.com/iissnan/hexo-theme-next/commits/master" target="_blank" rel="noopener">master 分支</a>的话, 输入这个命令:</p>   <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br></pre></td></tr></table></figure><p><strong>3.</strong> 在 <strong>hexo 根目录下</strong> 的配置文件<code>_config.yml</code>里设置主题:</p><pre><code>theme: next</code></pre><h3 id="Bugs"><a href="#Bugs" class="headerlink" title="Bugs"></a>Bugs</h3><p>对于那些遇到 <strong>Error: Cannot find module ‘hexo-util’</strong> <a href="https://github.com/iissnan/hexo-theme-next/issues/1490" target="_blank" rel="noopener">问题</a>的人, 请检查你的NPM 版本. </p><ul><li><code>版本 &gt; 3</code>: 如果仍然不行的话，请移除 <code>node_modules</code> 文件 然后重新安装，使用 <code>npm install</code>命令。</li><li><code>版本 &lt; 3</code>: 请通过<code>npm install --save-dev hexo-util</code>命令添加<code>hexo-util</code>到你的站点包依赖里</li></ul><h2 id="更新-Update"><a href="#更新-Update" class="headerlink" title="更新 Update"></a>更新 Update</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> themes/next</span><br><span class="line">$ git pull</span><br></pre></td></tr></table></figure><h3 id="Bugs-1"><a href="#Bugs-1" class="headerlink" title="Bugs"></a>Bugs</h3><blockquote><p>提交您的更改或存储它们，然后才能合并。</p></blockquote><p>您必须提交，存储或放弃本地更改. 看 <a href="https://stackoverflow.com/a/15745424/5861495" target="_blank" rel="noopener">here</a> 是如何做的。</p><h3 id="使用Hexo-data-files-328-配置主题-Theme-configurations-using-Hexo-data-files-328"><a href="#使用Hexo-data-files-328-配置主题-Theme-configurations-using-Hexo-data-files-328" class="headerlink" title="使用Hexo data files(#328)配置主题  Theme configurations using Hexo data files #328"></a>使用Hexo data files(<a href="https://github.com/iissnan/hexo-theme-next/issues/328" target="_blank" rel="noopener">#328</a>)配置主题  Theme configurations using Hexo data files #328</h3><p>目前升级 NexT 主题的时候并不是非常的流畅。若使用 <code>git pull</code> 的方式，很多时候可能会产生冲突；而下载新版本覆盖安装的方式又需要手动合并主题的 <code>_config.yml</code> 文件。</p><p>在此修改之前， NexT 建议将配置分离，一部分在 站点的配置文件中，另外一部分在主题的配置文件中。将需要自定的选项放置在 站点配置文件中，从而脱离避免更新主题时可能遇到的麻烦。这种方式是可行，但是有一些缺点：</p><ol><li>配置分离成了两个部分</li><li>用户可能会疑惑一些选项该放置在哪里比较合适</li></ol><p>为了解决这个问题， NexT 将会使用 Hexo 的 <a href="https://hexo.io/docs/data-files.html" target="_blank" rel="noopener">Data Files</a> 。然而由于 Data Files 是在 Hexo 3 版本时引进的，所以要使用这个特性，需要 Hexo 的版本不低于 3。</p><p>若你比较喜欢 Hexo 2.x 版本，可以继续使用原先的配置方式。 NexT 保持着向下兼容。</p><h4 id="特性-Benefits"><a href="#特性-Benefits" class="headerlink" title="特性 Benefits"></a>特性 Benefits</h4><p>通过这个特性，你可以将所有的主题配置放置在站点的 <code>source/_data/next.yml</code> 文件中。原先放置在 站点配置文件 中的选项可以迁移到新的位置，同时，主题配置文件可以不用做任何修改。若后续版本有配置相关的改动时，你仅需在 <code>next.yml</code> 中做相应调整即可</p><h4 id="如何使用这个特性-How-to-use-this-feature"><a href="#如何使用这个特性-How-to-use-this-feature" class="headerlink" title="如何使用这个特性 How to use this feature"></a>如何使用这个特性 How to use this feature</h4><ol><li>请先确保你所使用的 Hexo 版本在 3 以上</li><li>在站点的 <code>source/_data</code> 目录下新建 <code>next.yml</code> 文件（<code>_data</code>目录可能需要新建）</li><li>迁移站点配置文件和主题配置文件中的配置到 <code>next.yml</code> 中</li><li>使用 <code>--config source/_data/next.yml</code> 参数启动服务器, 生成或者部署。\<br>例如: <code>hexo clean --config source/_data/next.yml &amp;&amp; hexo g --config source/_data/next.yml</code>。</li></ol><h2 id="特色-Features"><a href="#特色-Features" class="headerlink" title="特色 Features"></a>特色 Features</h2><h3 id="支持多国语言-包括"><a href="#支持多国语言-包括" class="headerlink" title="支持多国语言, 包括:"></a>支持多国语言, 包括:</h3><p>:cn: 简体中文 &amp; 繁体中文<br><br>:us: 英语<br><br>:ru: 俄语<br><br>:fr: 法语<br><br>:de: 德语<br><br>:jp: 日语<br><br>:indonesia: 印度尼西亚语<br><br>:portugal: 葡萄牙语 (巴西)<br><br>:kr: 朝鲜语<br><br>:it: 意大利语<br><br>:netherlands: 荷兰语</p><p>默认语言是英语。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">en</span></span><br><span class="line"><span class="comment"># language: zh-Hans</span></span><br><span class="line"><span class="comment"># language: zh-hk</span></span><br><span class="line"><span class="comment"># language: zh-tw</span></span><br><span class="line"><span class="comment"># language: ru</span></span><br><span class="line"><span class="comment"># language: fr-FR</span></span><br><span class="line"><span class="comment"># language: de</span></span><br><span class="line"><span class="comment"># language: ja</span></span><br><span class="line"><span class="comment"># language: id</span></span><br><span class="line"><span class="comment"># language: pt</span></span><br><span class="line"><span class="comment"># language: pt-BR</span></span><br><span class="line"><span class="comment"># language: ko</span></span><br><span class="line"><span class="comment"># language: it</span></span><br><span class="line"><span class="comment"># language: nl-NL</span></span><br></pre></td></tr></table></figure><p>在站点配置文件<code>_config.yml</code>中可以将语言切换成中文</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">zh-Hans</span></span><br></pre></td></tr></table></figure><h3 id="评论支持-Comment-support"><a href="#评论支持-Comment-support" class="headerlink" title="评论支持 Comment support"></a>评论支持 Comment support</h3><p>NexT 已经原生支持 <code>多说</code> and <code>Disqus</code> 评论系统。</p><p>添加以下代码到你的主题配置文件 <code>_config.yml</code>:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">duoshuo:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  shortname:</span> <span class="string">your-duoshuo-shortname</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">disqus_shortname:</span> <span class="string">your-disqus-shortname</span></span><br></pre></td></tr></table></figure><h3 id="标签页-Tags-page"><a href="#标签页-Tags-page" class="headerlink" title="标签页 Tags page"></a>标签页 Tags page</h3><blockquote><p>添加一个标签页面，里面包含您网站中的所有标签。</p></blockquote><ul><li><p>创建一个名为 <code>tags</code> 页面</p><pre><code>hexo new page &quot;tags&quot;</code></pre></li><li><p>编辑标签页, 设置页面类型为<code>tags</code>.</p><pre><code>title: All tagsdate: 2014-12-22 12:39:04type: &quot;tags&quot;</code></pre></li><li><p>添加 <code>tags</code> 到主题配置文件 <code>_config.yml</code> 里:</p><pre><code>menu:  home: /  archives: /archives  tags: /tags</code></pre></li></ul><h3 id="分类页-Categories-page"><a href="#分类页-Categories-page" class="headerlink" title="分类页 Categories page"></a>分类页 Categories page</h3><blockquote><p>添加一个分类页面，里面包含您网站中的所有分类。</p></blockquote><ul><li><p>创建一个名为 <code>categories</code> 页面</p><pre><code>hexo new page &quot;categories&quot;</code></pre></li><li><p>编辑分类页, 设置页面类型为 <code>categories</code>.</p><pre><code>title: All categoriesdate: 2014-12-22 12:39:04type: &quot;categories&quot;</code></pre></li><li><p>添加 <code>categories</code> 到主题配置文件 <code>_config.yml</code> 里:</p><pre><code>menu:  home: /  archives: /archives  categories: /categories</code></pre></li></ul><h3 id="社交媒体-Social-Media"><a href="#社交媒体-Social-Media" class="headerlink" title="社交媒体 Social Media"></a>社交媒体 Social Media</h3><p>NexT 可以自动添加链接到您的社交媒体帐户里:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line"><span class="attr">  GitHub:</span> <span class="string">your-github-url</span></span><br><span class="line"><span class="attr">  Twitter:</span> <span class="string">your-twitter-url</span></span><br><span class="line"><span class="attr">  Weibo:</span> <span class="string">your-weibo-url</span></span><br><span class="line"><span class="attr">  DouBan:</span> <span class="string">your-douban-url</span></span><br><span class="line"><span class="attr">  ZhiHu:</span> <span class="string">your-zhihu-url</span></span><br></pre></td></tr></table></figure><h3 id="Feed-链接-Feed-link"><a href="#Feed-链接-Feed-link" class="headerlink" title="Feed 链接 Feed link"></a>Feed 链接 Feed link</h3><blockquote><p>显示 feed 链接。</p></blockquote><p>在主题配置文件<code>_config.yml</code>里设置<code>rss</code> , 如下所示:</p><ol><li><code>rss: false</code> 会禁用 feed 链接。</li><li><p><code>rss:</code> 使用站点 feed 链接。这是默认的选项。</p><p> 按照插件<a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="noopener">hexo-generator-feed</a>的README中的安装说明进行操作。在完成这个插件的配置后，Feed链接也生成好了</p></li><li><p><code>rss: http://your-feed-url</code> 设置你的 feed 链接.</p></li></ol><h3 id="内置5种代码高亮主题-Up-to-5-code-highlight-themes-built-in"><a href="#内置5种代码高亮主题-Up-to-5-code-highlight-themes-built-in" class="headerlink" title="内置5种代码高亮主题 Up to 5 code highlight themes built-in"></a>内置5种代码高亮主题 Up to 5 code highlight themes built-in</h3><p>NexT 使用的是 <a href="https://github.com/chriskempson/tomorrow-theme" target="_blank" rel="noopener">Tomorrow 主题</a> ，一共有5种主题供你选择。<br>Next 默认使用 <code>normal</code>. 下面是 <code>normal</code> 和 <code>night</code> 主题的预览:</p><p><img src="http://iissnan.com/nexus/next/tomorrow-normal.png" alt="Tomorrow Normal Preview"><br><img src="http://iissnan.com/nexus/next/tomorrow-night.png" alt="Tomorrow Night Preview"></p><p>查看更多信息点击<a href="https://github.com/chriskempson/tomorrow-theme" target="_blank" rel="noopener">Tomorrow 主题</a>。</p><h2 id="配置-Configuration"><a href="#配置-Configuration" class="headerlink" title="配置 Configuration"></a>配置 Configuration</h2><p>NexT 的配置很少</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Menu configuration.</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">  home:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">  archives:</span> <span class="string">/archives</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Favicon</span></span><br><span class="line"><span class="attr">favicon:</span> <span class="string">/favicon.ico</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Avatar (put the image into next/source/images/)</span></span><br><span class="line"><span class="comment"># can be any image format supported by web browsers (JPEG,PNG,GIF,SVG,..)</span></span><br><span class="line"><span class="attr">avatar:</span> <span class="string">/default_avatar.png</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Code highlight theme</span></span><br><span class="line"><span class="comment"># available: normal | night | night eighties | night blue | night bright</span></span><br><span class="line"><span class="attr">highlight_theme:</span> <span class="string">normal</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Fancybox for image gallery</span></span><br><span class="line"><span class="attr">fancybox:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Specify the date when the site was setup</span></span><br><span class="line"><span class="attr">since:</span> <span class="number">2013</span></span><br></pre></td></tr></table></figure><h2 id="浏览器支持-Browser-support"><a href="#浏览器支持-Browser-support" class="headerlink" title="浏览器支持 Browser support"></a>浏览器支持 Browser support</h2><p><img src="http://iissnan.com/nexus/next/browser-support.png" alt="Browser support"></p><p><a href="https://www.browserstack.com/" target="_blank" rel="noopener"><img src=".github/browserstack_logo.png" alt="Browser Stack"></a></p><blockquote><p><strong>BrowserStack</strong> is a cloud-based cross-browser testing tool that enables developers to test their websites across various browsers on different operating systems and mobile devices, without requiring users to install virtual machines, devices or emulators.</p></blockquote><h2 id="贡献-Contributing"><a href="#贡献-Contributing" class="headerlink" title="贡献 Contributing"></a>贡献 Contributing</h2><p>接受各种形式的贡献，包括不限于提交问题与需求，修复代码。等待您的<code>Pull Request</code>。</p><p>Any types of contribution are welcome. Thanks.</p><p><strong>ATTENTION! Contributors on Chinese docs needed!</strong>\<br>Need to translate from <a href="README.md">English docs</a> to Chinese docs.\<br>Any help wanted!\<br>Thank’s a lot!</p><h2 id="开发-Development"><a href="#开发-Development" class="headerlink" title="开发 Development"></a>开发 Development</h2><p>NexT 主旨在于简洁优雅且易于使用，所以首先要尽量确保 NexT 的简洁易用性。</p><p>NexT is built for easily use with elegant appearance. First things first, always keep things simple.</p><h2 id="开发历史-Changelog"><a href="#开发历史-Changelog" class="headerlink" title="开发历史 Changelog"></a><a href="https://github.com/iissnan/hexo-theme-next/wiki/Changelog" target="_blank" rel="noopener">开发历史 Changelog</a></h2><!--[lic-image]: https://img.shields.io/npm/l/hexo-theme-next.svg-->]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;e-x-T&quot;&gt;&lt;a href=&quot;#e-x-T&quot; class=&quot;headerlink&quot; title=&quot; e x T&quot;&gt;&lt;/a&gt;&lt;div align=&quot;center&quot;&gt;&lt;a href=&quot;https://github.com/iissnan/hexo-theme-nex
      
    
    </summary>
    
      <category term="Github" scheme="http://cydrain.github.io/categories/Github/"/>
    
    
  </entry>
  
  <entry>
    <title>实现简单内存管理-2</title>
    <link href="http://cydrain.github.io/2017/12/10/%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-2/"/>
    <id>http://cydrain.github.io/2017/12/10/实现简单内存管理-2/</id>
    <published>2017-12-10T04:09:13.000Z</published>
    <updated>2017-12-10T08:11:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>用内存池的方式实现简单的内存管理。</p><p>一个内存池只提供一定大小的内存结点，如4-byte，8-byte，16-byte … …<br>malloc 的时候，从<code>avail_head</code>拿，加到<code>used_tail</code>；<br>free 的时候，从<code>used_head</code>~<code>used_tail</code>链表中搜到该结点并删除，然后加回<code>avail_tail</code>。</p><p>内存池结构体定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct _mem_pool &#123;</span><br><span class="line">    short       pool_size;      // 内存池容量</span><br><span class="line">    short       node_size;      // 每个内存结点提供的内存大小</span><br><span class="line">    short       node_num;       // 内存结点数目</span><br><span class="line">    short       used_num;       // 已使用内存结点数目</span><br><span class="line">    mem_node    avail_head;     // 空内存结点头</span><br><span class="line">    mem_node    avail_tail;     // 空内存结点尾</span><br><span class="line">    mem_node    used_head;      // 已使用内存结点头</span><br><span class="line">    mem_node    used_tail;      // 已使用内存结点尾</span><br><span class="line">    void*       data_addr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>内存结点结构体定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct _mem_node &#123;</span><br><span class="line">    short       used;</span><br><span class="line">    short       index;</span><br><span class="line">    mem_node*   prev;</span><br><span class="line">    mem_node*   next;</span><br><span class="line">    char        addr[0];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>完整代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line"></span><br><span class="line">typedef unsigned long ulong;</span><br><span class="line">typedef struct _mem_node mem_node;</span><br><span class="line">struct _mem_node &#123;</span><br><span class="line">    short       used;</span><br><span class="line">    short       index;</span><br><span class="line">    mem_node*   prev;</span><br><span class="line">    mem_node*   next;</span><br><span class="line">    char        addr[0];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct _mem_pool mem_pool;</span><br><span class="line">struct _mem_pool &#123;</span><br><span class="line">    short       pool_size;</span><br><span class="line">    short       node_size;</span><br><span class="line">    short       node_num;</span><br><span class="line">    short       used_num;</span><br><span class="line">    mem_node    avail_head;</span><br><span class="line">    mem_node    avail_tail;</span><br><span class="line">    mem_node    used_head;</span><br><span class="line">    mem_node    used_tail;</span><br><span class="line">    void*       data_addr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">enum &#123;</span><br><span class="line">    MEM_POOL_4 = 0,</span><br><span class="line">    MEM_POOL_8,</span><br><span class="line">    MEM_POOL_16,</span><br><span class="line">    MEM_POOL_32,</span><br><span class="line">    MEM_POOL_64,</span><br><span class="line">    MEM_POOL_128,</span><br><span class="line">    MEM_POOL_256,</span><br><span class="line">    MEM_POOL_NUM</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">mem_pool* mem_pool_array[MEM_POOL_NUM];</span><br><span class="line"></span><br><span class="line">/* detach mem_node from random position */</span><br><span class="line">void mem_node_detach(mem_node* node, mem_node* head, mem_node* tail)</span><br><span class="line">&#123;</span><br><span class="line">    assert(node != NULL);</span><br><span class="line">    node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">    node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* pop the first mem_node */</span><br><span class="line">mem_node* mem_node_pop(mem_node* head, mem_node* tail)</span><br><span class="line">&#123;</span><br><span class="line">    mem_node* node;</span><br><span class="line">    node = head-&gt;next;</span><br><span class="line">    head-&gt;next = node-&gt;next;</span><br><span class="line">    node-&gt;next-&gt;prev = head;</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* append mem_node to the list tail */</span><br><span class="line">void mem_node_append(mem_node* node, mem_node* head, mem_node* tail)</span><br><span class="line">&#123;</span><br><span class="line">    assert(node != NULL);</span><br><span class="line">    tail-&gt;prev-&gt;next = node;</span><br><span class="line">    node-&gt;next = tail;</span><br><span class="line">    node-&gt;prev = tail-&gt;prev;</span><br><span class="line">    tail-&gt;prev = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mem_pool* mem_pool_init(int node_size, int node_num)</span><br><span class="line">&#123;</span><br><span class="line">    mem_pool* pool = NULL;</span><br><span class="line">    mem_node* node = NULL;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    pool = (mem_pool*)malloc(sizeof(mem_pool));</span><br><span class="line">    if (pool == NULL) &#123;</span><br><span class="line">        printf(&quot;mem_pool malloc fail!\n&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    memset(pool, 0, sizeof(mem_pool));</span><br><span class="line">    pool-&gt;node_size = node_size;</span><br><span class="line">    pool-&gt;node_num = node_num;</span><br><span class="line">    pool-&gt;pool_size = node_num * (node_size + sizeof(mem_node));</span><br><span class="line"></span><br><span class="line">    pool-&gt;data_addr = malloc(pool-&gt;pool_size);</span><br><span class="line">    if (pool-&gt;data_addr == NULL) &#123;</span><br><span class="line">        printf(&quot;Fail to malloc %d bytes memory for mem_pool %p\n&quot;,</span><br><span class="line">                pool-&gt;pool_size, pool);</span><br><span class="line">        goto FAIL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pool-&gt;avail_head.next = &amp;pool-&gt;avail_tail;</span><br><span class="line">    pool-&gt;avail_tail.prev = &amp;pool-&gt;avail_head;</span><br><span class="line">    pool-&gt;used_head.next = &amp;pool-&gt;used_tail;</span><br><span class="line">    pool-&gt;used_tail.prev = &amp;pool-&gt;used_head;</span><br><span class="line"></span><br><span class="line">    pool-&gt;avail_head.index = -1;</span><br><span class="line">    pool-&gt;avail_tail.index = -1;</span><br><span class="line">    pool-&gt;used_head.index = -1;</span><br><span class="line">    pool-&gt;used_tail.index = -1;</span><br><span class="line"></span><br><span class="line">    node = (mem_node*)pool-&gt;data_addr;</span><br><span class="line">    for (i = 0; i &lt; node_num; i++) &#123;</span><br><span class="line">        node-&gt;used = 0;</span><br><span class="line">        node-&gt;index = i;</span><br><span class="line">        mem_node_append(node, &amp;pool-&gt;avail_head, &amp;pool-&gt;avail_tail);</span><br><span class="line">        node = (mem_node*)((ulong)node + sizeof(mem_node) + node_size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return pool;</span><br><span class="line">FAIL:</span><br><span class="line">    if (pool != NULL) free(pool);</span><br><span class="line">    return NULL;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void mem_pool_free(mem_pool* ptr)</span><br><span class="line">&#123;</span><br><span class="line">    assert(ptr != NULL);</span><br><span class="line">    free(ptr-&gt;data_addr);</span><br><span class="line">    free(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void mem_pool_show(mem_pool* pool)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;MEM_POOL %p:\n&quot;, pool);</span><br><span class="line">    printf(&quot;\tpool_size\t: %d\n&quot;, pool-&gt;pool_size);</span><br><span class="line">    printf(&quot;\tnode_size\t: %d\n&quot;, pool-&gt;node_size);</span><br><span class="line">    printf(&quot;\tnode_num\t: %d\n&quot;, pool-&gt;node_num);</span><br><span class="line">    printf(&quot;\tused_num\t: %d\n&quot;, pool-&gt;used_num);</span><br><span class="line">    printf(&quot;\tdata_addr\t: %p\n&quot;, pool-&gt;data_addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void mem_pool_array_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; MEM_POOL_NUM; i++) &#123;</span><br><span class="line">        mem_pool_array[i] = mem_pool_init(1&lt;&lt;(i+2), 100);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void mem_pool_array_free(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; MEM_POOL_NUM; i++) &#123;</span><br><span class="line">        mem_pool_free(mem_pool_array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void mem_pool_array_show(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for (i = 0; i &lt; MEM_POOL_NUM; i++) &#123;</span><br><span class="line">        mem_pool_show(mem_pool_array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mem_pool* get_mem_pool_by_size(size_t size)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; MEM_POOL_NUM; i++) &#123;</span><br><span class="line">        if (size &lt;= mem_pool_array[i]-&gt;node_size) break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return mem_pool_array[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mem_pool* get_mem_pool_by_addr(void* addr)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; MEM_POOL_NUM; i++) &#123;</span><br><span class="line">        if (addr &gt; mem_pool_array[i]-&gt;data_addr &amp;&amp;</span><br><span class="line">            addr &lt; (void*)((ulong)mem_pool_array[i]-&gt;data_addr + mem_pool_array[i]-&gt;pool_size))</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return mem_pool_array[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void* myMalloc(size_t size)</span><br><span class="line">&#123;</span><br><span class="line">    mem_pool* pool = NULL;</span><br><span class="line">    mem_node* node = NULL;</span><br><span class="line"></span><br><span class="line">    pool = get_mem_pool_by_size(size);</span><br><span class="line">    if (pool == NULL) &#123;</span><br><span class="line">        printf(&quot;Fail to get valid mem_pool for size %d.\n&quot;, (int)size);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (pool-&gt;used_num == pool-&gt;node_num) &#123;</span><br><span class="line">        printf(&quot;mem_pool with node size %d is full\n&quot;, pool-&gt;node_size);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node = mem_node_pop(&amp;pool-&gt;avail_head, &amp;pool-&gt;avail_tail);</span><br><span class="line">    assert(node-&gt;used == 0);</span><br><span class="line">    node-&gt;used = 1;</span><br><span class="line">    mem_node_append(node, &amp;pool-&gt;used_head, &amp;pool-&gt;used_tail);</span><br><span class="line">    pool-&gt;used_num++;</span><br><span class="line"></span><br><span class="line">    return node-&gt;addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myFree(void* ptr)</span><br><span class="line">&#123;</span><br><span class="line">    mem_pool* pool = NULL;</span><br><span class="line">    mem_node* node = NULL;</span><br><span class="line"></span><br><span class="line">    pool = get_mem_pool_by_addr(ptr);</span><br><span class="line"></span><br><span class="line">    node = (mem_node*)((ulong)ptr - sizeof(mem_node));</span><br><span class="line">    assert(node-&gt;used == 1);</span><br><span class="line">    mem_node_detach(node, &amp;pool-&gt;used_head, &amp;pool-&gt;used_tail);</span><br><span class="line">    node-&gt;used = 0;</span><br><span class="line">    mem_node_append(node, &amp;pool-&gt;avail_head, &amp;pool-&gt;avail_tail);</span><br><span class="line">    pool-&gt;used_num--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#define TEST_NUM        100000</span><br><span class="line">#define ARRAY_NUM       200</span><br><span class="line">#define MAX_MALLOC_SIZE 150</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i, idx;</span><br><span class="line">    void* ptr[ARRAY_NUM];</span><br><span class="line"></span><br><span class="line">    mem_pool_array_init();</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; ARRAY_NUM; i++) &#123;</span><br><span class="line">        ptr[i] = NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; TEST_NUM; i++) &#123;</span><br><span class="line">        idx = random() % ARRAY_NUM;</span><br><span class="line">        if (ptr[idx] == NULL) &#123;</span><br><span class="line">            ptr[idx] = myMalloc(random() % MAX_MALLOC_SIZE + 1);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            myFree(ptr[idx]);</span><br><span class="line">            ptr[idx] = NULL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mem_pool_array_show();</span><br><span class="line"></span><br><span class="line">    mem_pool_array_free();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用内存池的方式实现简单的内存管理。&lt;/p&gt;
&lt;p&gt;一个内存池只提供一定大小的内存结点，如4-byte，8-byte，16-byte … …&lt;br&gt;malloc 的时候，从&lt;code&gt;avail_head&lt;/code&gt;拿，加到&lt;code&gt;used_tail&lt;/code&gt;；&lt;b
      
    
    </summary>
    
      <category term="Memory" scheme="http://cydrain.github.io/categories/Memory/"/>
    
    
  </entry>
  
  <entry>
    <title>实现简单内存管理-1</title>
    <link href="http://cydrain.github.io/2017/12/10/%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-1/"/>
    <id>http://cydrain.github.io/2017/12/10/实现简单内存管理-1/</id>
    <published>2017-12-10T03:56:16.000Z</published>
    <updated>2017-12-13T12:23:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>在一块给定的内存上实现简单的内存管理。</p><p>从内存中划出一块用于内存管理结点<code>mem_node</code>，malloc/free 的内存信息存在一个个<code>mem_node</code>中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------------------------------+</span><br><span class="line">|                                               |</span><br><span class="line">|                                               |</span><br><span class="line">|                                               |</span><br><span class="line">|                                               |</span><br><span class="line">|                  Memory  Pool                 |</span><br><span class="line">|                                               |</span><br><span class="line">|                                               |</span><br><span class="line">|                                               |</span><br><span class="line">|                                               |</span><br><span class="line">+-----------------------------------------------+</span><br><span class="line">| mem_node1 | mem_node2 | mem_node3 | mem_node4 |</span><br><span class="line">+-----------------------------------------------+</span><br><span class="line">| mem_node5 | mem_node6 | mem_node7 | mem_node8 |</span><br><span class="line">+-----------------------------------------------+</span><br><span class="line">|  ... ...  |  ... ...  |  ... ...  |  ... ...  |</span><br><span class="line">+-----------------------------------------------+</span><br><span class="line">|  ... ...  | mem_node98| mem_node99|mem_node100|</span><br><span class="line">+-----------------------------------------------+</span><br></pre></td></tr></table></figure></p><p><code>mem_node</code>的结构体定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">short</span> used;</span><br><span class="line">    <span class="keyword">short</span> size;</span><br><span class="line">    <span class="keyword">void</span>* start_addr;</span><br><span class="line">&#125; mem_node;</span><br></pre></td></tr></table></figure></p><p>在申请内存的时候，先找到一个空余的<code>mem_node</code>，并且该结点所能提供的内存要大于或等于申请内存。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">myMalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NODE_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node[i].used == <span class="number">0</span> &amp;&amp; node[i].size &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node[i].size &gt; size) &#123;</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; NODE_NUM; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (node[j].used == <span class="number">0</span> &amp;&amp; node[j].size == <span class="number">0</span>) &#123;</span><br><span class="line">                        node[j].size = node[i].size - size;</span><br><span class="line">                        node[j].start_addr = node[i].start_addr + size;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j == NODE_NUM) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"Have reached the max memory nodes %d limits!\n"</span>, NODE_NUM);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node[i].used = <span class="number">1</span>;</span><br><span class="line">            node[i].size = size;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _DEBUG_</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"malloc %d, %p\n"</span>, node[i].size, node[i].start_addr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="keyword">return</span> node[i].start_addr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Cannot find enough memory piece %d!\n"</span>, (<span class="keyword">int</span>)size);</span><br><span class="line">    <span class="comment">//showMemNode();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在释放内存的时候，先找到该块内存对应的内存管理结点，并把它的状态改为“可用”。<br>并且检查该<code>mem_node</code>的头或尾是否与别的<code>mem_node</code>相连，如果有，合并这两个结点。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFree</span><span class="params">(<span class="keyword">void</span>* ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NODE_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node[i].used == <span class="number">1</span> &amp;&amp; node[i].start_addr == ptr) &#123;</span><br><span class="line">            node[i].used = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == NODE_NUM) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Invalid free ptr %p!\n"</span>, ptr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _DEBUG_</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"free %d, %p\n"</span>, node[i].size, node[i].start_addr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* merge node[i] backward */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; NODE_NUM; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node[j].used == <span class="number">0</span> &amp;&amp;</span><br><span class="line">            node[j].start_addr == node[i].start_addr + node[i].size) &#123;</span><br><span class="line">            node[i].size += node[j].size;</span><br><span class="line"></span><br><span class="line">            node[j].size = <span class="number">0</span>;</span><br><span class="line">            node[j].start_addr = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* merge node[i] forward */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; NODE_NUM; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node[j].used == <span class="number">0</span> &amp;&amp;</span><br><span class="line">            node[i].start_addr == node[j].start_addr + node[j].size) &#123;</span><br><span class="line">            node[j].size += node[i].size;</span><br><span class="line"></span><br><span class="line">            node[i].size = <span class="number">0</span>;</span><br><span class="line">            node[i].start_addr = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>完整代码请参考:[<a href="https://github.com/cydrain/Coding_Practice/blob/master/myCode/myMalloc/myMalloc.c" target="_blank" rel="noopener">https://github.com/cydrain/Coding_Practice/blob/master/myCode/myMalloc/myMalloc.c</a>]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在一块给定的内存上实现简单的内存管理。&lt;/p&gt;
&lt;p&gt;从内存中划出一块用于内存管理结点&lt;code&gt;mem_node&lt;/code&gt;，malloc/free 的内存信息存在一个个&lt;code&gt;mem_node&lt;/code&gt;中。&lt;br&gt;&lt;figure class=&quot;highligh
      
    
    </summary>
    
      <category term="Memory" scheme="http://cydrain.github.io/categories/Memory/"/>
    
    
  </entry>
  
  <entry>
    <title>github.io 更新与备份</title>
    <link href="http://cydrain.github.io/2017/12/09/HelloWorld/"/>
    <id>http://cydrain.github.io/2017/12/09/HelloWorld/</id>
    <published>2017-12-09T06:06:13.000Z</published>
    <updated>2017-12-10T03:46:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="完整操作如下：（摘自知乎回答）"><a href="#完整操作如下：（摘自知乎回答）" class="headerlink" title="完整操作如下：（摘自知乎回答）"></a>完整操作如下：（摘自知乎回答）</h1><ol><li>创建仓库 cydrain.github.io;</li><li>创建两个分支：master 与 hexo;<br>git branch hexo</li><li>设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）;</li><li>使用 git clone git@github.com:cydrain/cydrain.github.io.git 拷贝仓库;</li><li>在本地 cydrain.github.io 文件夹下通过Git bash依次执行<br>npm install hexo<br>hexo init<br>npm install<br>npm install hexo-deployer-git（此时当前分支应显示为hexo）;</li><li>修改 _config.yml 中的 deploy 参数，分支应为master；</li><li>依次执行<br>git add .<br>git commit -m “…”<br>git push origin hexo 提交网站相关的文件；</li><li>执行 hexo generate -d 生成网站并部署到 GitHub 上。</li></ol><h1 id="本地资料丢失"><a href="#本地资料丢失" class="headerlink" title="本地资料丢失"></a>本地资料丢失</h1><p>当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：<br>使用 git clone git@github.com:cydrain/cydrain.github.io.git 拷贝仓库（默认分支为hexo）;<br>在本地新拷贝的 cydrain.github.io 文件夹下通过 Git bash 依次执行下列指令：<br>   npm install hexo<br>   npm install<br>   npm install hexo-deployer-git（记得，不需要hexo init这条指令）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;完整操作如下：（摘自知乎回答）&quot;&gt;&lt;a href=&quot;#完整操作如下：（摘自知乎回答）&quot; class=&quot;headerlink&quot; title=&quot;完整操作如下：（摘自知乎回答）&quot;&gt;&lt;/a&gt;完整操作如下：（摘自知乎回答）&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;创建仓库 cydrain
      
    
    </summary>
    
      <category term="Github" scheme="http://cydrain.github.io/categories/Github/"/>
    
    
  </entry>
  
</feed>
